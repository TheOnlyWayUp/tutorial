[{"body":" In this bonus section I'll cover the Discord feature of allowed mentions.\nFirst, what are allowed mentions? Allowed mentions are a way of telling Discord that you don't want to ping for certain mentions in your message. The different types of ping a message can have are @role pings, @everyone or @here pings, @user pings, and reply pings, all of which we can turn on and off pings for when mentioning.\nHow do I use them? There're a couple of ways you can use allowed mentions in discord.py:\nIn the bot's constructor The first way we can set allowed mentions in the bot's constructor, and these will apply on all messages sent by the bot. To do this we need to import discord.py to use them:\n1import discord 2from discord.ext import commands Next, we need to create the bot:\n1bot = commands.Bot( 2 command_prefix=\u0026#34;!\u0026#34;, 3 allowed_mentions=discord.AllowedMentions( 4 users=False, # Whether to ping individual user @mentions 5 everyone=False # Whether to ping @everyone or @here mentions 6 roles=False, # Whether to ping role @mentions 7 replied_user=False, # Whether to ping on replies to messages 8 ), 9) The example above will disable all pings in messages the bot sends, but you can toggle these as you like. Try making your bot send mentions with these settings to see allowed mentions in action!\nPer message The next way of setting allowed mentions is when sending a message, or replying to one. Either way it uses the same keyword argument, so I'll just show sending a message normally, and you can adapt that to your own code. Again the first thing we need to do if we havent already is import discord.py so we can access the AllowedMentions class:\n1import discord 2from discord.ext import commands Now, I'll assume that we're in a cogso I can create a command like this:\n1 @commands.command(name=\u0026#34;dontpingme\u0026#34;) 2 async def dont_ping_me(self, ctx: commands.Context): 3 am = discord.AllowedMentions( 4 users=False, 5 ) 6 await ctx.send(f\u0026#34;Hello, {ctx.author.mention}\u0026#34;, allowed_mentions=am) This example only disabled the users mention, since it's the only one that will happen, which means now you can run that command and the bot will mention you, but won't ping you. Neat, huh?\nNote that when using allowed mentions in a message specifically, any mentions you have set in the AllowedMentions object will override those mentions' settings that were set in the bot's constructor.  ","link":"https://vcokltfre.dev/tips/mentions/","title":"Allowed Mentions"},{"body":" I often see a lot of people using the wrong one, so here's a guide for which you should use.\ndiscord.Client The Client class is made specifically to connect to the gateway and handle API requests. As such it's not suitable for the majority of bot applications, and using commands.Bot is preferable since it will handle command parsing, permssion checks, etc for you.\ndiscord.ext.commands.Bot The Bot class is designed specifically for you to create functional bots with. It has far more features than the Client class alone, such as commands, cogs, permissions checks, cooldowns, custom checks you can create, command error handling, and more. Generally speaking you should be using this not client, there are very very few occasions you need to use client.\nFeature Comparison    Client Bot     Connects to the gateway Connects to the gateway   Handles API calls, obeying ratelimits Handles API calls, obeying ratelimits   Can handle individual events, i.e. message_create Can handle individual events, i.e. message_create   Can automatically shard Can automatically shard   - Can handle user defined commands   - Can put events and commands in separate files using cogs   - Can do built-in permission checks on commands   - Can create custom checks for commands   - Can have easy error handlers for commands   - Can create cooldowns for commands     A Note About Naming If you are using discord.Client you should name that variable client, likewise, if you are using commands.Bot you should name that variable bot. If you stick to naming things like this it will help you and other people understand your code, and make it easier for people to help if something breaks. Good naming matters. Readability counts. Please name your variables correctly, naming a Bot client is akin to creating a variable called integer and setting it to a string.\nCorrect:\n1bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) Incorrect:\n1client = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) ","link":"https://vcokltfre.dev/tips/clientbot/","title":"Client vs Bot"},{"body":"Tips:  Tips - Tokens Tips - Allowed Mentions Tips - Client vs Bot Tips - Gateway Intents Tips - Storing Data  ","link":"https://vcokltfre.dev/tips/","title":"discord.py tips"},{"body":" Intents are an important part of Discord which I briefly cover in this tutorial part, but which deserve their own section explaining them in more depth, so here it is!\n1 - What are Gateway Intents? Gateway intents are a way of getting only the data your application needs from the Discord gateway. When you first identify with the gateway upon starting your bot you send the intents you are going to use as an integer which represents a field of bits that describe which intents you need.\nThere are a few different gateway intents that you can select:\n   Gateway Intent Name in Docs Bit Shift Description Privileged     GUILDS 1 \u0026lt;\u0026lt; 0 Allows you to receive guild events like joining/leaving guilds, role events, and channel events. No   GUILD_MEMBERS 1 \u0026lt;\u0026lt; 1 Allows you to receive member events like joins and leaves. Yes   GUILD_BANS 1 \u0026lt;\u0026lt; 2 Allowd you to receive ban add and remove events. No   GUILD_EMOJIS 1 \u0026lt;\u0026lt; 3 Allows you to receive emoji updates. No   GUILD_INTEGRATIONS 1 \u0026lt;\u0026lt; 4 Allows you to receive integration update events. No   GUILD_WEBHOOKS 1 \u0026lt;\u0026lt; 5 Allows you to receive webhook update events. No   GUILD_INVITES 1 \u0026lt;\u0026lt; 6 Allows you to receive invite create and delete events. No   GUILD_VOICE_STATES 1 \u0026lt;\u0026lt; 7 Allows you to receive voice state update events. No   GUILD_PRESENCES 1 \u0026lt;\u0026lt; 8 Allows you to receive members' presence updates. Yes   GUILD_MESSAGES 1 \u0026lt;\u0026lt; 9 Allows you to receive message events like create and delete from guilds. No   GUILD_MESSAGE_REACTIONS 1 \u0026lt;\u0026lt; 10 Allows you to receive message reaction events like add and remove on guild messages. No   GUILD_MESSAGE_TYPING 1 \u0026lt;\u0026lt; 11 Allows you to receive typing events in guilds. No   DIRECT_MESSAGES 1 \u0026lt;\u0026lt; 12 Allows you to receive message events like create and delete from DMs. No   DIRECT_MESSAGE_REACTIONS 1 \u0026lt;\u0026lt; 13 Allows you to receive message reaction events like add and remove on DM messages. No   DIRECT_MESSAGE_TYPING 1 \u0026lt;\u0026lt; 14 Allows you to receive typing events in DMs. No    Bear in mind that these intents often also determine which data you receive upon connecting to the gateway. For example if you have members intents disabled you will not receive guild member lists upon connecting, in addition to not receiving member events.  Enabling Privileged Intents To enable privileged intents for your application, first head over to the Discord developer portal and click on your application. Next, head to the Bot tab on the left, and scroll down to the privileged intents section:\nBeyond 100 servers you bot will need to be verified and whitelisted for these intents to be able to use them.  Now you can select either or both of these intents so that you can use them in your code. Bear in mind that if one of these intents is not enabled on this page you cannot use it when connecting to the gateway.\nUsing Intents in Your Bot Let's start out with a simple bot setup:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) This example has most of the intents enabled, all except members and presences. There are a couple of ways we can enable these intents, the first option being using all intents - which you should only use if you actually use both memebrs and presence intents:\n1from discord.ext import commands 2from discord import Intents 3 4bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=Intents.all())  You shouldn't use all intents like this unless you actually use them!  The next method is to create a default intents object, and explicitly enable an intent on it, in this example I'll enabled the members intent since this is the most common one to need:\n1from discord.ext import commands 2from discord import Intents 3 4intents = Intents.default() 5intents.members = True 6 7bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=intents) That's pretty much it for gateway intents, they're not too complicated but can definitely catch you out if you don't know about them, so watch out for where you might need to change them!\n","link":"https://vcokltfre.dev/tips/intents/","title":"Gateway Intents"},{"body":"Content soonTM\n","link":"https://vcokltfre.dev/tips/optional/","title":"Optional Arguments"},{"body":" As your bot grows in features you'll probably want to store persistent data, and it's important to do this in the correct way, else you can make your life developing harder, and possibly compromise the functionality of your bot.\nIf you have one takeaway from this, let it be that JSON is not a database, and does not work as one, nor does CSV, or plain text files. JSON works well as a data transfer format, or for config files, but is not made for storing changeable persistent data.  Databases You Can Use Note that the following libraries are async libraries. discord.py is an async library too, so the libraries you use inside it should also be async to prevent blocking calls from stopping the event loop doing important things, such as heartbeating to the Discord gateway.  PostgreSQL Postgres is a popular SQL database due to its large feature set and efficiency, and is generally a good choice when storing data in a bot.\nTo use postgres in your bot you'll want to use a client library such as asyncpg which provides an easy interface for interacting with Postgres.\nMySQL / MariaDB MySQL or it's younger sibling MariaDB are also popular SQL databases which are also extremely commonly used. For most bots there will be no noticable difference between MySQL-based and Postgres, so it's really up to personal preference\nTo use MySQL or MariaDB in your bot you'll want the aiomysql client library, which also provides an easy interface for interacting with MySQL.\nMongoDB MongoDB is a document store, not a relational database like MySQL or PostgreSQL, which means its usecases are slightly different. MongoDB is primarily for storing JSON-like objects but in a proper database so you don't need to handle file storage and other general shenanigans when storing data.\nTo use MongoDB in your bot you'll want to use the motor client library. Motor also provides an easy interface for interacting with MongoDB, but in a very different way to the previous SQL databases mentioned, since it's fundamentally a different kind of database.\nResources    Resource Description     asyncpg docs The official asyncpg documentation   aiomysql docs The official aiomysql documentation   motor docs The official motor documentation   PostgreSQL tutorial A tutorial to help you learn how to use Postgres   MySQL tutorial A tutorial to help you learn how to use MySQL and MariaDB    ","link":"https://vcokltfre.dev/tips/storage/","title":"Storing Data"},{"body":"In this bonus section I'll explain the 3 most common methods of storing the token for your bot. Note that for these examples you should assume that there is a bot defined somewhere else in the code, and the line bot.run(token) is at the bottom. I won't show the bot code in each example to show just the necessary information, and make this applicable outside of Discord bots too.\nYou should also be sure when using git to gitignore all of the files you store sensitive information in from any of these examples, to avoide committing them to version control.  .env files and the python-dotenv module One of the most standard methods in programming of storing your secret static data is in .env files, and this is used for far more than just Discord bots. To store your token in a .env file is quite simple.\nFirstly, you need a file named just .env which you can use to store the token. This file should look like the following:\nTOKEN='your_token_here' That's all there is to the file, but to access it in python we need to do a bit more work. First, we need to install the python-dotenv package using pip install python-dotenv (or likely pip3 if you're on Linux) which will install the module. Now we need to import the module and actually load the file:\n1from dotenv import load_dotenv 2 3load_dotenv() # You can pass the location of the .env file if it\u0026#39;s not in a standard location Now that we've imported the module and loaded the file, we need to access the token from it. To do this we need to import the os module so that we can access the environment variables:\n1from dotenv import load_dotenv 2from os import getenv 3 4load_dotenv() 5 6token = getenv(\u0026#34;TOKEN\u0026#34;) That's it! The token is now loaded and ready to use.\nImporting from python files Another technique you can use is to import the token from a python file. This is far simpler than loading from a .env file as it requires no external modules and is just a regular python import.\nAssuming you have a folder named private and in it a file called config.py, you can simply use the following code to import the token from it:\n1from private.config import token Which assumes config.py looks like this:\n1token = \u0026#34;abcd_my_token\u0026#34; YAML and JSON config files The last common technique is using YAML and JSON files to store your token. First, I'll assume you have either a config.yml or config.json file. You're free to use whichever of these two you like, just look at the correct section for your type.\nYAML First, the file (config.yml) should look like the folowing:\n1token:\u0026#34;abcd_my_token\u0026#34;Next, you'll need to have the pyyaml module installed, which can be installed using pip install pyyaml (or likely pip3 if you're on Linux) which will install the module. Now we need to import and load the data from that file:\n1from yaml import safe_load 2from pathlib import Path 3 4with Path(\u0026#34;config.yml\u0026#34;).open() as f: 5 config = safe_load(f) 6 7token = config[\u0026#34;token\u0026#34;] JSON For JSON it's more simple than YAML since no non-standard modules are needed, simply create a file (config.json) like the following:\n1{ 2 \u0026#34;token\u0026#34;:\u0026#34;abcd_my_token\u0026#34; 3} Next, we just need to load that token:\n1from json import load 2from pathlib import Path 3 4with Path(\u0026#34;config.json\u0026#34;).open() as f: 5 config = load(f) 6 7token = config[\u0026#34;token\u0026#34;] Which to choose Generally it's up to you which to choose for your project. Each has it's advantages and disadvantages.\n.env:    Advantages Disadvantages     Supported widely, including by things like Docker/docker-compose. Limited available data types.   No changes needed when setting the environment variable otherwise. Requires an additonal module not in the standard library.    Author's note: I actually can't think of more than this for .env, personally I dislike using .env files, but if you have anything else to put here please open an issue. config.py    Advantages Disadvantages     Easy to import from without any other modules. Less parsable if other programs need to access the data which aren't in python.   More complex data structures and being able to use python objects and operations.     config.json \u0026amp; config.yml    Advantages Disadvantages     Generally more complex data structures than .env. Not as complex as python structures can be.   Easy to group data, such as perhaps database credentials. Requires an additional module not in the standard library for YAML.    ","link":"https://vcokltfre.dev/tips/tokens/","title":"Tokens"},{"body":" Cogs are a very important part of discord.py, which are discussed in this tutorial part, but that's more of a guide starting from the start, rather than showing how to transfer an existing bot to use cogs, so that's what this bonus part is for!\nI'll be using typehinting (e.g def foo(bar: Baz):) throughout this part. Not doing so will not cause any difference to the bot, however it will make it so that there are far less useful code suggestions from your IDE, so generally I'd recommend using it where possible.  Firstly, here's a simple bot which I'll be transitioning to cogs:\n1from discord.ext import commands 2from discord import Message 3from dotenv import load_dotenv 4from os import getenv 5 6load_dotenv() # To learn more about this visit https://vcokltfre.dev/tips/tokens/ 7 8bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 9 10@bot.event 11async def on_message(message: Message): 12 if message.author.bot: 13 return 14 15 if \u0026#34;hello\u0026#34; in message.content.lower(): # A simple example, don\u0026#39;t want to get too complex 16 await message.channel.send(\u0026#34;Hi!\u0026#34;) 17 18 await bot.process_commands(message) 19 20@bot.command(name=\u0026#34;ping\u0026#34;) 21async def ping(ctx: commands.Context): 22 \u0026#34;\u0026#34;\u0026#34;Show the bot\u0026#39;s gateway latency.\u0026#34;\u0026#34;\u0026#34; 23 await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) 24 25bot.run(getenv(\u0026#34;TOKEN\u0026#34;))  In case you didn't know, it's very important here in the on_message event that we use bot.process_commands afterwards, that way we can still handle commands, else no commands will be handled at all. This not an issue when using @bot.listen() rather than @bot.event, or when using cogs.  Beyond this point you will need at least a basic understanding of Object Oriented Programming (OOP)/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial.  Next, we can move on to actually creating the cog itself, which we are going to do in a different file called mycog.py:\n1from discord.ext import commands 2 3 4class MyCog(commands.Cog): # All cogs must inherit from commands.Cog 5 \u0026#34;\u0026#34;\u0026#34;A simple, basic cog.\u0026#34;\u0026#34;\u0026#34; 6 7 def __init__(self, bot: commands.Bot): 8 self.bot = bot 9 10 11def setup(bot: commands.Bot): 12 bot.add_cog(MyCog(bot)) The first important thing to note here is that wehn creating the class we have a bot argment in the cog's constructor. This means that we can have cogs in other files without needing to somehow import and reference the bot from the main file.\nNext, there's the setup function. This is what discord.py looks out for when trying to load the cog. It must be called setup else the cog will fail to load and you'll get an error.\nNow that we have a simple cog we can add in out existing listener and commmand to it:\n1from discord.ext import commands 2from discord import Message 3 4 5class MyCog(commands.Cog): # All cogs must inherit from commands.Cog 6 \u0026#34;\u0026#34;\u0026#34;A simple, basic cog.\u0026#34;\u0026#34;\u0026#34; 7 8 def __init__(self, bot: commands.Bot): 9 self.bot = bot 10 11 @commands.Cog.listener() 12 async def on_message(self, message: Message): 13 if message.author.bot: 14 return 15 16 if \u0026#34;hello\u0026#34; in message.content.lower(): 17 await message.channel.send(\u0026#34;Hi!\u0026#34;) 18 19 @commands.command(name=\u0026#34;ping\u0026#34;) 20 async def ping(self, ctx: commands.Context): 21 \u0026#34;\u0026#34;\u0026#34;Show the bot\u0026#39;s gateway latency.\u0026#34;\u0026#34;\u0026#34; 22 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) 23 24 25def setup(bot: commands.Bot): 26 bot.add_cog(MyCog(bot)) There are several key changes here that need to be noted:\n We're now passing self as the first argument to each function, this is because we're inside a class now. We no longer need to call process_commands in the on_message listener, since now it's a listener rather than an event. When getting the bot's latency we now use self.bot.latency, again because we're now inside a class.  Ok great! We have a cog, now we need to load this cog in the main file. I've stripped the event and command out, since they're not in the cog, so here's what we're left with:\n1from discord.ext import commands 2from discord import Message 3from dotenv import load_dotenv 4from os import getenv 5 6load_dotenv() 7 8bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 9 10bot.run(getenv(\u0026#34;TOKEN\u0026#34;)) Now, we need to add just a single line of code to load that cog we just made:\n1from discord.ext import commands 2from discord import Message 3from dotenv import load_dotenv 4from os import getenv 5 6load_dotenv() 7 8bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 9 10bot.load_extension(\u0026#34;mycog\u0026#34;) # \u0026lt;--- This single line of code to be precise 11 12bot.run(getenv(\u0026#34;TOKEN\u0026#34;))  It's highly recommended that you include some error handling around cog loading, but how that's implemented is up to you. It may also be useful to have a list of cogs and iterate over them and call load_extension so that you don't repeat yourself.  load_extension works in a similar way to import. For example let's say we have the following directory structure:\n/ bot.py /cogs mycog.py /utils prefix.py We can load mycog from bot.py by using load_extension(\u0026quot;cogs.mycog\u0026quot;)\nThere's a lot more you can do with cogs too, such as reloading cogs, or running code on cog load, unload, and reload. For a more comprehensive list of things cogs can do you should see the discord.py docs page on cogs.\n ","link":"https://vcokltfre.dev/tips/cogs/","title":"Transitioning to Cogs"},{"body":"This is a page to show credits and special thanks for help people have provided with this tutorial, or things within it.\nFirstly, thanks to Danny/Rapptz for making discord.py, without which this tutorial would obviously not exist, nor would countless amazing bots using the discord.py library. His Github profile can be found here.\nNext, anand/ares initially helped me a great deal with getting the site up on Github pages, and making the first pages version. A link to their Github profile can be found here.\nEnormous thanks to TizzySaurus for sitting for about 2.5 hours with me going through every part making sure it was correct, fixing spelling errors, formatting, and making a bunch more awesome suggestions. I don't know your Github profile, but you helped so much so thanks!\nFinally, as much as I don't want to, apparently I should give myself credit, so my Github profile can be found here :P and the repo for this tutorial can be found here.\nBack to the Index ","link":"https://vcokltfre.dev/tutorial/00-credits/","title":"00 - Credits and Special Thanks"},{"body":"This section of the tutorial will show you how to create a new bot and add it to your server.\nTo create Discord applications and bots you will need a verified email address.  The first thing you need to do to create a bot is head over to the Discord Developer Portal where you'll be asked to log in to your Discord account. Upon logging in you'll see a screen like this:\nNow that you're logged into the developer portal you need to create a new application by clicking the shiny blue New Application button in the top right hand corner. After you click it you should see a box like this pop up:\nBe sure to enter a suitable and good name for your bot - and be sure to follow the Discord Terms of Service, so no slurs or harassment. To be clear this applies to the entire tutorial and you should not use any of the knowledge you gain from it to perform actions that are not allowed by it. You can read the Terms of Service here, and the Developer Terms here.\nAs a rough overview here are some things you should know about the ToS:\n Don't abuse the API Don't harass users.  So don't randomly DM or spam them.   Don't spam Discord.  Generally actions performed by a bot should be caused by some user action like sending a message or adding a reaction.   Don't post NSFW content in channels not marked as NSFW.  This may seem obvious but a lot of bots allow NSFW content to be posted outside of NSFW channels. This is not allowed.     For this tutorial the bot will be named WumpusBot and will be referred to as that elsewhere in the tutorial.\nAfter creating your application you'll see a screen like this:\nYou likely want to set your bot to private - at least while testing - so that other people can't add your bot to their servers.  There's quite a lot of information on this screen, so for now we'll ignore most of it since it's out of scope for the beginning of this tutorial. Click on the Bot tab on the left hand side (marked by a jigsaw piece) to switch to the bot page. On this page you'll see a button that says Add Bot. Clicking this will prompt you if you're sure you want to create a new bot (you can't delete bots since they're too cool to destroy), click Yes, do it! and now you have your very own bot.\nAfter creating a bot your screen will change to look like this:\nBelow the username box you'll see a button that says Copy which copies your bot's authentication token to your clipboard. You'll want to keep this token safe and on hand so your bot can connect to Discord later on in the tutorial.\nFinally for this part, you need to add your bot to your server. To do this you first require the Manage Server permission in whatever server you plan on adding it to. You’ll want to head over to the OAuth2 tab on the left of the developer portal (marked by a wrench), where you’ll be able to choose the scopes you want for your bot. For now, just select the bot scope, as it’s all that will be needed for this tutorial - at least at the beginning.\nNow you’ll want to choose permissions for your bot based on what you want it to do. For WumpusBot, I’ll start by giving it Send Messages, Embed Links, Attach Files, Manage Messages, and Add Reactions, although we may need more permissions later, but that will be handled within Discord itself.\nIt is highly recommended that you never give bots the Administrator permission, even if it feels easier than giving the bot just what’s needed. Please do not give your bots administrator.  In the end your permissions should look like this:\nNow you can copy the URL in the box above, and paste it into your browser, then follow the steps to add the bot to your server of choice.\nThat's it for the first part of the tutorial, you've created your very own bot user on Discord. Now you just have to do the fun bit - adding features - after all, what's a bot without features?\nA quick note on tokens: You should make an effort to keep your token safe at all times. This means not sharing it with anyone or accidentally uploading it in code samples. If someone gains access to your bot’s token they then have full control of the bot, and can perform actions with it that you may not want. If you believe that your bot’s token was leaked, be sure to go to it’s developer portal page and click the Regenerate button to regenerate the token so that nobody can use the old one.\nFor more info in how you should store tokens see this bonus part.\n Next: An Overview of Discord ","link":"https://vcokltfre.dev/tutorial/01-setup/","title":"01 - Creating a Bot User"},{"body":"In this part of the tutorial, I’ll try to give a rough explanation of how Discord functions. If you already have a decent understanding of websockets, the API, and Discord terminology, you can likely move on to 03 - Hello, World!\n1: The Discord Gateway The Discord gateway is how your bot receives events from Discord, so understanding it can be useful to understand what a bot's capabilities are and what Discord gives you to work with.\nSo, what actually is this Discord Gateway you keep mentioning? The gateway is actually a fairly simple websocket connection to Discord - basically a web request that connects a socket, which then stays open so that Discord can send events to you, rather than you fetching events from Discord. Neat, huh?\nWhile you're using discord.py you don't actually have to worry about connecting to the gateway yourself, because the library does that all for you, but I believe nonetheless it's useful to have an understanding of how the underlying architecture works, which often makes the higher level stuff make more sense.\nWhen discord.py receives an event from the gateway it will have an OPCODE and some event data, and a couple of other pieces of data we won't worry about for now. These tell your client what to do with the payload, such as hearbeating to the gateway to show the client is still alive.\nIf the OPCODE passed is 0, that means it's a dispatch event, and those are the ones we're interested in, because they contain the interesting events like message creations, member joins, and any other typical Discord event like them.\nThat's pretty much it for the gateway at this level. There is a lot more detail that can be talked about with the gateway, but that's out of the scope of this tutorial, and if you're interested in further reading the official Discord documentation for the gateway can be found here.\n2: The API The Discord API is how our bot talks back to Discord. We've got the events from the gateway and we've processed them, but without the API we can't actually do anything with that. If you've ever sent a message on Discord, added a reaction, renamed a channel, or performed almost any other action, you've made API requests to the Discord API to do that.\nWell, bots are much the same, only they don't have access to all the same endpoints as the user client (although, that being said they do have access to a couple of exclusive endpoints, like locking the use of an emoji to a specific role!).\nAgain, as with the gateway, discord.py handles interaction with the API and abstracts away most of the complexity like passing tokens in headers and handling ratelimits.\n3: Discord Terminology In Discord there are a few special words for things which we need to understand and be able to differentiate between.\n   Term Description     guild The internal word that Discord has for what you know as a server.   user A Discord user, not containing information relating to a guild.   member A Discord user, with guild context. You'll only receive members if you have the server members gateway intent enabled, which will be explained later, or sometimes in other events like voice state updates and as the author in message events.    And that's pretty much it for this part of the tutorial. I hope this has given you at least some useful knowledge about roughly how Discord works, and now you can move on to the next part!\nNext: Hello, world! ","link":"https://vcokltfre.dev/tutorial/02-overview/","title":"02 - An Overview of Discord"},{"body":"In this part, I’ll show you the basics of how to create a super simple bot and get it connected to Discord. From now on it is assumed that you have the discord.py library installed, along with a version of Python which is 3.6 or above, as versions before this don’t have all the features used in this tutorial.\nThe first step to creating a bot is to import the discord.ext.commands module of discord.py so that we can create the bot:\n1from discord.ext import commands # This is the part of discord.py that helps us build bots Epic! Now that we can use the discord.ext.commands module, we need to actually create a bot instance that will run our commands:\n1bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) As you can see, the first thing we need to do is tell the bot which command prefix to use, otherwise how can it know when a command is called and that it should respond?\nThis prefix can actually be one of many things, but for the sake of this tutorial I'll just be using the string \u0026quot;!\u0026quot; for the prefix. For now just know that it is possible to create more complex prefixes, such as a different prefix for each server.  The bot constructor is also where we would specify what are known as gateway intents - essentially telling the gateway which events we want. For now we'll ignore this, however it will be covered in part 7 when we need to use events not given with the default intents.\nNext, we want to add a command to the bot so that it can do something. The first command we'll add is a !hello command, that responds with \u0026quot;Hello, world!\u0026quot;\n1@bot.command(name=\u0026#34;hello\u0026#34;) 2async def hello_world(ctx: commands.Context): 3 await ctx.send(\u0026#34;Hello, world!\u0026#34;)  By default, the bot will ignore other bots messages, so sending !hello from another bot won't trigger the command.  That's quite a lot to take in, even if you're quite familiar with Python, so allow me to explain what each piece of it does:\n @bot.command(name=\u0026quot;hello\u0026quot;) is a decorator that converts the function below it into a command that you can run from Discord. async def hello_world(ctx: commands.Context): defines a hello_world function that takes 1 argument - ctx - which is a Context object that's passed with every command. All commands will be passed a Context object as their first argument. await ctx.send(\u0026quot;Hello, world!\u0026quot;) makes an API call to Discord to send a message to the channel the command was run in with the content \u0026quot;Hello, world!\u0026quot; Note that ctx.send() is an alias of ctx.channel.send(), and functions exactly the same, just in a more concise way.  Note that explicitly setting the name in the command decorator is optional, as without it the command will inherit the function name, and often will not be needed, whether to use it is up to you.  Next, we need to run the bot with its token that you got from the developer portal in 01 - Creating a Bot User:\n1bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  This runs the bot with your token, and abstracts away creating an event loop and running the bot through coroutines.\nAt this point, your bot should be entirely functional, and if you start it up in your preferred method, you should see it come online and answer commands.\nCommon ways of starting your bot:\n running python bot.py pressing F5 in most IDEs   Next: A Ping Command ","link":"https://vcokltfre.dev/tutorial/03-hello/","title":"03 - Hello, world!"},{"body":"So far we've made a pretty simple bot - it only responds to !hello with a static response. Not particularly interesting, is it? Let's fix that! In this part we'll be creating a ping command that shows the bot's gateway websocket latency when you call it.\nAs with the previous part we'll want to import and set up the bot like below:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5@bot.command(name=\u0026#34;hello\u0026#34;) 6async def hello_world(ctx: commands.Context): 7 await ctx.send(\u0026#34;Hello, world!\u0026#34;) 8 9bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  But now we want to add another command between the hello command and where we run the bot. Note that if you put the command after running the bot it will never be called since running the bot creates a blocking loop, preventing execution of code after it, until the bot shuts down.\nThe command will look like this:\n1@bot.command(name=\u0026#34;ping\u0026#34;) 2async def ping(ctx: commands.Context): 3 await ctx.send(f\u0026#34;Pong! {round(bot.latency * 1000)}ms\u0026#34;) This will send a message that says something along the lines of \u0026quot;Pong! 113ms\u0026quot; which is the amount of time between discord.py sending a gateway heartbeat and it receiving an acknowledgement from the gateway. In the response we're using an f-string (Python 3.6 and above) so that we can use inline code within the string, in this case the bot's latency is measured in seconds, but we want it in milliseconds, so we multiply it by 1000 and round it to remove the decimals.\nIt's that simple, you've added another command, go ahead and run the bot to try it out! If it works it should look like the following:\nWell done! You're already 4 parts in, fortunately there's a lot more to learn, so you can now move on to the next part.\nNext: Cogs ","link":"https://vcokltfre.dev/tutorial/04-pong/","title":"04 - A Ping Command"},{"body":"Cogs are a very important part of discord.py which allow you to organise your commands into groups - not to be confused with actual command groups, which will be explained later in the tutorial.\nCogs represent a fairly drastic change in the way you write commands and bots, so it's good that we're getting into them here before you're too used to sticking the commands in the main file of the bot.\nCogs require a basic understand of OOP/classes in Python. If you're not familiar with this, check out the first video in Corey Schafer's OOP Tutorial.  To start out with cogs we're going to abandon the code from the previous sections largely in favour of new commands tailored to cogs. First, I'll show how to make a cog still in the main file of the bot, then I'll show you how to move it into a separate file completely.\nFirstly, as with the previous samples, we need to import the commands module of discord.py and create a bot:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) Next, we need to create a class that inherites from commands.Cog that we can put our commands in, and a constructor that takes in the bot as its only argument and saves it (at this point I'll also start adding docstrings, those things between \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;, that explain what cogs or commands are for, and are used in the built-in help command):\n1class SomeCommands(commands.Cog): 2 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; 3 4 def __init__(self, bot: commands.Bot): 5 self.bot = bot If you didn't know yet, bot: commands.Bot is known as typehinting, and it gives the IDE you're using (or sometimes discord.py itself) a hint as to what type the argument is. You'll see this come in handy later on when we add arguments of certain types to our commands.\nNow we want to add back the commands we had before. For the sake of simplicity, we wont add back the hello command, it was a good starting point but in reality commands with static output aren't that interesting, so we probably wont use them much more.\nIn cogs, commands have their own way of being defined, which is using the commands.command() decorator. It serves the same function as bot.command(), however it now works in cogs too:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; 4 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Note that we're now using self as the first argument of the command function, because we're now in a class.\nNow we have another step we have to do before we run the bot (and I promise this extra effort will pay off in the long run when you understand the code better and can find things easier!) which is to add the cog to the bot. We do that like this:\n1bot.add_cog(SomeCommands(bot)) That's it, we've added the cog to the bot, now we can run it in the normal way and test out our ping command now using cogs!\n1bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Great! It works! But we haven't really solved the problem we had before, which was having everything in one file, in fact we've added to the amount of code in the single file, which is doing the exact opposite of what we were trying to do. So, how do we solve this? Well, with more files of course! discord.py's Bot provides another useful function which is load_extension(), which will load cogs from another file.\nTo start with, let's set up the main bot file, we'll call it bot.py from now on with the following code (this is not the final code for this file, we'll update it in a bit to reflect the changes we are about to make):\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  Basically, we've stripped most of the logic out because we're going to move that to another file, somecommands.py, so let's create that file and add some code:\n1from discord.ext import commands # Again, we need this imported 2 3 4class SomeCommands(commands.Cog): 5 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; 6 7 def __init__(self, bot: commands.Bot): 8 self.bot = bot 9 10 @commands.command(name=\u0026#34;ping\u0026#34;) 11 async def ping(self, ctx: commands.Context): 12 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; 13 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) # It\u0026#39;s now self.bot.latency  As you can see in the above examples, cog classes must derive from commands.Cog else they will not work.  Finally for this file, we need to add a setup function so that discord.py can load the cog:\n1def setup(bot: commands.Bot): 2 bot.add_cog(SomeCommands(bot))  The name of this function must be setup as this is what discord.py will use to load it.  And that's most of the work done to move it into its own file, we just need to update bot.py to make it load this cog, because currently it has no idea there's a cog here that it needs to load. To do this we'll use the load_extension() function I mentioned earlier:\n1from discord.ext import commands 2 3bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;) 4 5bot.load_extension(\u0026#34;somecommands\u0026#34;) # Note, we don\u0026#39;t need the .py file extension 6 7bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's it for the basics of cogs, you now know how to create a cog, create commands in that cog, and then load the cog into the bot!\nExtra reading discord.py actually provides us with a way to easily create new bots and cogs through its module's CLI. As a rough overwiew it provides the commands newbot and newcog, which auto generate bots and cogs respectively.\nnewbot This creates a new bot, by default in the current directory, with a given name. The avilable options are:\n name [required] : The bot's name. directory [optional, default=.] : The directory to create the bot in. prefix [optional, default=$] : The bot's prefix. sharded [optional] : Whether the bot should use AutoShardedClient  Note that sharding likely won't be of use to you until about 2,000 servers, and is enforced by the gateway at 2,500.   no-git : Whether the project should be created without a git project.  A command to create a typic new bot might look like this:\npython -m discord newbot TestBot --prefix !\nnewcog This creates a new cog in the cogs folder of the current directory by default, with a given name. The avilable options are:\n name [required] : The cog's name. directory [optional, default=cogs] : The directory to create the cog in. class-name [optional, default=[name]] : The cog's class name. display-name [optional, default=[name]] : The cog's display name. hide-commands [optional] : Whether to hide the commands in the cog from the help command. full [optional] : Whether to add special cog methods too.  A command to create a typical new cog might look like this:\npython -m discord newcog mycog\n Next: Online! ","link":"https://vcokltfre.dev/tutorial/05-cogs/","title":"05 - Cogs"},{"body":"You've learned how to make commands, and how to make cogs, so now that you know how to use both, let's make something a little more complicated and useful - a command that sets your bot's status.\nFor this part we'll start off with the same files we ended with in the last part, which means we'll be adding our new command to somecommands.py, and in fact we won't even need to change the main bot file, that can stay just as it is.\nTo recap, here's the somecommands.py file from the last part:\n1from discord.ext import commands # Again, we need this imported 2 3 4class SomeCommands(commands.Cog): 5 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; 6 7 def __init__(self, bot: commands.Bot): 8 self.bot = bot 9 10 @commands.command(name=\u0026#34;ping\u0026#34;) 11 async def ping(self, ctx: commands.Context): 12 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; 13 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) 14 15 16# Now, we need to set up this cog somehow, and we do that by making a setup function: 17def setup(bot: commands.Bot): 18 bot.add_cog(SomeCommands(bot)) To add the new status command we want to put it just after the ping command - inside the class. For this command we'll be introduced to a couple of new things. Firstly, we're going to need to import the main discord.py library to use a certain class from it, and second this command needs to take in text to set the status to.\nTo start with, you'll need to add this line to the top of your file to import the main discord.py library:\n1import discord Now you can add a new command under ping that lets you change the status, which will look like this (don't worry, I'll explain all the new stuff we see after the code):\n1 @commands.command(name=\u0026#34;setstatus\u0026#34;) 2 async def setstatus(self, ctx: commands.Context, *, text: str): 3 \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; 4 await self.bot.change_presence(activity=discord.Game(name=text)) The first new thing here is this bit:\n1, *, text: str This essentially takes all user input after the command and passes it as the text parameter. This is where it's useful to have the typehints I mentioned earlier, as it tells discord.py's converters which type to convert the arguments given into.\nNext, we have a change_presence function on the bot. In Discord a status is more broadly known as a presence and can include info such as Spotify statuses for non bot users. change_presence, as its name suggests, changes the bot's status to the value given. In this case we give it a discord.Game object whose name is whatever text we gave, which will make the status look like \u0026quot;Playing {text}\u0026quot;\nNote that in this function we dont use ctx, but it still needs to be part of the function defintion, as discord.py always passes it first in commands.  Now you should be able to test it out and see the bot set its status to something you type in, if you run a command like !setstatus Minecraft.\nAnd that's the end of part 6! Now you can move on to the next part - Welcome.\nNext: Welcome ","link":"https://vcokltfre.dev/tutorial/06-online/","title":"06 - Online!"},{"body":"Ok, so far we've learned how to make a bot, add commands, use cogs, and change the status. Let's combine some of this and a bit of new stuff to make something that welcomes users with a custom message when they join a server.\nTo start out, we'll once again use the same code from the previous part and add to that. First, we have a modification we need to make to the bot.py file. Up until this point we've been using the default gateway intents that discord.py sends to the gateway - which is all except the privileged intents (server members and presences).\nBefore we can proceed to modify the code, we need to enable these privileged intents on the Discord developer portal. Go to your bot's bot page on the portal, and scroll down to the privileged intents section:\nBeyond 100 servers you bot will need to be verified and whitelisted for these intents to be able to use them.  Now, you need to enable the server members intent, and click save to update the application.\nIntents exist for a good reason - to reduce computational burden. On larger bots it may be an issue to have these intents enabled as it means Discord sends a lot more data to the bot, which may overwhelm it, although this should not be an issue for small or even fairly large bots.  Even without the server members intent enabled, Discord will sometimes still provide you with members, such as in messages, voice state updates, etc. This means that you can often use them as members in things like commands, and they will populate the member cache too. The main thing to note is that with members intent disabled, you will not initially be given the member list, you will not receive member updates such as joins/leaves/nickname changes, and you will not be able to fetch members from the API.  With that done, let's get back to the code - this will be the last time we have to visit the developer portal for a while. First, we need to tell discord.py to use these intents when connecting to the gateway, which we'll do by creating an intents object with the default intents, and enabling members intent, after which the bot file will look like this:\n1import discord 2from discord.ext import commands 3 4intents = discord.Intents.default() 5intents.members = True 6 7bot = commands.Bot(command_prefix=\u0026#34;!\u0026#34;, intents=intents) 8 9bot.load_extension(\u0026#34;somecommands\u0026#34;) 10 11bot.run(\u0026#34;your_token_here\u0026#34;)  This is a insecure way of setting the token used for brevity, please read this bonus part about storing tokens.  That's all that needed to enable intents, and now we can harness the full power of Discord gateway events! Now, we have to create the code that welcomes people, which we will stick in the somecommands.py for now, but you're free to make another file and another cog, and load it in the same way as before.\nAgain, this will be within the class, just under the commands we already have - but wait, this isn't a command, its an event. Luckily discord.py has us covered for events too, and provides listeners so that we can use them.\nAs with previous examples I'll show the code we need to use and then explain what the new bits do afterwards:\n1 @commands.Cog.listener() 2 async def on_member_join(self, member: discord.Member): 3 channel = self.bot.get_channel(799309066202775624) 4 5 if not channel: 6 return 7 8 await channel.send(f\u0026#34;Welcome, {member}!\u0026#34;) Ok, quite a lot to cover with this one. First, we have a new decorator, commands.Cog.listener(). This is like commands.command(), only it now receives different gateway events rather than messages, in this case the member join event (a full list of events can be found here in the documentation) which gives us details about a member joining a guild.\nNext, we get a channel from the bot, this is the channel that we'll send the welcome message in. To do this we use self.bot.get_channel() to get a channel from the bot's cache of channels.\nNote that I explicitly use the word get here, not fetch. This is because in discord.py, and now throughout this tutorial, get will refer to fetching something from the local cache, and fetch will mean fetching something from the API. It's important to distinguish which is which, because the get methods are synchronous, while fetch methods are asynchronous and must be awaited.  Now, you'll likely have noticed the long number in there, that's the channel's unique snowflake ID. All objects in Discord, be it a role, channel, guild, user, etc. have an ID (excluding things like permission overwrites which just map user and role IDs to a set of permissions) which can be found in the client by right clicking the object and clicking copy ID. To have this option you need to have developer mode enabled. Make sure to replace my channel ID with one of your own, or the message won't be sent!\nNext, we need to check if we actually have a channel to send to, since it's not guaranteed, so we check if channel is truthy, and return if it isnt.\nFinally, we send a message to the channel which welcomes the user. In f-string expressions or when converting discord.py objects to strings in general, perhaps using str(), if the object has a name attribute that's what it will convert to. For members and users however it's slightly more, and it will convert to the username and discriminator, which is the four numbers after the #, so let's take my user object for example, if we do str(vcokltfre_user) we'll get 'vcokltfre#6868' - which in a welcome message is preferable to pinging people when they join, which can be quite annoying. It's also recommended that you dont DM people welcome messages either.\nIt's possible to mention the user without pinging them using a Discord feature called allowed mentions which discord.py has support for. If you would like to learn more about allowed mentions please read this bonus part.  If you do decide to have the bot DM people on join do be careful - Discord will disable and quarantine a bot's access to DMing people if it DMs members too quickly. This applies in general not just with welcome messages.  That's it for this part - your bot should now have a fully functioning welcome message when new people join the server. If it doesn't work be sure to check that you have used the correct channel ID for the channel you want to send it in, and that the ID is an integer, not a string.\nNow you're ready to move on to the next part!\nNext: A Better Ping Command ","link":"https://vcokltfre.dev/tutorial/07-welcome/","title":"07 - Welcome"},{"body":"In 04 - A Ping Command we made a simple ping command that shows the bot's websocket latency to the gateway, which in itself can be useful for seeing the latency, but it doesn't show API ping, which is another major factor in the bot's latency.\nTo add API latency we're going to send a message, and time how long it takes to send, then we'll edit that message to show the ping. This will be quite a short part, as it is just a modification to the existing ping command. To recap, here's the existing ping command:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket latency.\u0026#34;\u0026#34;\u0026#34; 4 await ctx.send(f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\u0026#34;) Firstly, we need to import the time module from the Python standard library. This means we can get the current UNIX time so that we can time the execution of sending the message, which will give us the API latency:\n1import time # Put this *at the top of the file* Now, I'll show the updated code, and then explain afterwards what was changed and why:\n1 @commands.command(name=\u0026#34;ping\u0026#34;) 2 async def ping(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;Get the bot\u0026#39;s current websocket and API latency.\u0026#34;\u0026#34;\u0026#34; 4 start_time = time.time() 5 message = await ctx.send(\u0026#34;Testing Ping...\u0026#34;) 6 end_time = time.time() 7 8 await message.edit(content=f\u0026#34;Pong! {round(self.bot.latency * 1000)}ms\\nAPI: {round((end_time - start_time) * 1000)}ms\u0026#34;) First, we set start_time to the current UNIX timestamp, then we send a message saying that we're testing ping, and then record the end_time. This is all fairly simple Python, or content we've covered earlier in the turorial, the main difference being that we store the message object returned by the API in the message variable.\nNow we see a new function we haven't used before, editing an existing message. Unlike sending a message, we need to specify that we're editing the content of the message. As with the previous ping command we show the websocket latency, but now we also show the latency to the API, calculated in much the same way.\nThat's it for this part of the tutorial, not a very long part but now you know how to edit messages, which can be quite useful. Now you can move on to the next part, What Did That Message Say?\nNext: What Did That Message Say? ","link":"https://vcokltfre.dev/tutorial/08-ping2/","title":"08 - A Better Ping Command"},{"body":"In this part I'll introduce a couple of new things we haven't met yet:\n The message delete event  and as such also what the message cache is   Embeds  The aim of this part is to teach you about how the on_message_delete event works, and creating an embed with the content of the deleted message to create a !snipe command.\nFirstly, we'll take the code from the previous parts. For this example I'll remove the current commands and events from somecommands.py so that we can focus on the main topic.\nWe will start out with the following code:\n1import discord 2from discord.ext import commands 3 4 5class SomeCommands(commands.Cog): 6 \u0026#34;\u0026#34;\u0026#34;A couple of simple commands.\u0026#34;\u0026#34;\u0026#34; 7 8 def __init__(self, bot: commands.Bot): 9 self.bot = bot 10 11 12def setup(bot: commands.Bot): 13 bot.add_cog(SomeCommands(bot)) Now that we have the base code there are a few things we need to add. Firstly we need to create an attribute of the cog that stores the last deleted message, which we'll set to None by default in the constructor:\n1 def __init__(self, bot: commands.Bot): 2 self.bot = bot 3 self.last_msg = None Following this we can move onto creating a listener for the on_message_delete event so that we can record when messages are deleted:\n1 @commands.Cog.listener() 2 async def on_message_delete(self, message: discord.Message): 3 self.last_msg = message  Again, typehinting is not strictly needed here, however in my IDE (VSCode) it means I get more useful code suggestions, so in that regard it's very useful.  Here's where the message cache comes in; this event will only trigger if the message that got deleted is in the bot's internal message cache, which it will only be if that message was received by the bot during it's current session. By default the message cache stores 1,000 messages, but this can be changed in the bot's constructor with the max_messages keyword argument. Messages sent before the bot was started won't fire on_message_delete events when deleted, nor will they fire on_message_edit events. It is however possible to listen to the raw delete and edit events, which will give you the raw payload data sent by Discord, without using the internal cache.\nNext, we need to add a command that lets us access this message, and then create an embed and send it, but we also need to handle the case that no message has been deleted since the bot started. As normal I'll show the code we're using and explain the new parts afterwards:\n1 @commands.command(name=\u0026#34;snipe\u0026#34;) 2 async def snipe(self, ctx: commands.Context): 3 \u0026#34;\u0026#34;\u0026#34;A command to snipe delete messages.\u0026#34;\u0026#34;\u0026#34; 4 if not self.last_msg: # on_message_delete hasn\u0026#39;t been triggered since the bot started 5 await ctx.send(\u0026#34;There is no message to snipe!\u0026#34;) 6 return 7 8 author = self.last_msg.author 9 content = self.last_msg.content 10 11 embed = discord.Embed(title=f\u0026#34;Message from {author}\u0026#34;, description=content) 12 await ctx.send(embed=embed) There's quite a lot to cover for this command, so we'll start at the beginning. First we check whether there is a last_message, if not we send a message saying so, and then return from the function so the rest of it doesnt execute.\nNext, we set a variable called content to the content of the message that was deleted, and author to the author of the deleted message. We could do this inline in the embed's constructor, but I've chosen not to here so that we dont have huge lines, but the functionality remains the same.\nNow, we create the embed itself. We want to give it the title of who deleted the message, so we use an f-string to put that in, and following that we set the description to the content variable we just made. That's about as simple as it gets for embeds, and in the next part I'll cover embeds in a lot more depth.\nFinally, we send embed to the channel. To do this we need to explicitly state that we want to send an embed with the embed keyword argument. If you test your bot now you should see something like this:\nAwesome! That's it for this part of the tutorial, you can now move on to part 10, All About Embeds!\nNext: All About Embeds ","link":"https://vcokltfre.dev/tutorial/09-snipe/","title":"09 - What Did That Message Say?"},{"body":"Nice! You're already 10 parts in, good job! In this part I'm going to show you all about embeds. I won't show the embeds in tandem with the actual bot, since we're focusing on creating them, but to send them you can use the method presented in 09 - What Did That Message Say?.\nFor this part I'll assume that you have imported discord at the top of your file.\nCreating an Embed Creating an embed is a simple as instantiating an Embed object like this:\n1embed = discord.Embed() But that is not a very useful (although still valid) embed, since it's empty. To make it useful we need to add content to the embed. The first way we can do this is with the title attribute:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;) Which will create an embed that looks like this:\nBut that's not a very interesting embed, there isn't much to it and it doesn't really display anything useful. One way we can add more to it is by adding a description:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;) Which will create the following embed:\nIt still feels like it's missing something important though... Ah yes! Colour! We can give an embed a colour by specifying the colour keyword argument, which is an integer (which I'll represent in hexadecimal for readability), or you can pass it a discord.py colour. For this example I'll use sky blue, 0x87CEEB, as it's a nice colour and quite possibly matches the colour of my logo:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) Which means we now have an embed that looks like this:\nHmmm... Better, but it still needs more... Let's give it a username and icon:\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) 2embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;)  You can also pass GIFs as parameters for image fields like avatar and thumbnail on embeds.  There we go, it's starting to look much nicer and more informative and full now, isn't it?\nBut there's still more that we can do! Embeds have a whole lot to offer to make an otherwise bland text chat more rich. Let's add some fields to show information. In this example it will be static information, but you can always replace it with dynamic content (think bot ping perhaps? I'll leave that as an exercise to the reader.)\n1embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB) 2embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) 3embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) 4embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) 5embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) As you can see, now we're able to make far more detailed embeds like this:\nAnd embeds still have more to offer, so for the sake of not making this part as long as a novel let's add a few now at the same time (we will need to import the datetime module for this due to the timestamp requiring it):\n1from datetime import datetime 2 3embed = discord.Embed(title=\u0026#34;Hello, world!\u0026#34;, description=\u0026#34;:D\u0026#34;, colour=0x87CEEB, timestamp=datetime.utcnow()) 4embed.set_author(name=\u0026#34;vcokltfre\u0026#34;, icon_url=\u0026#34;https://avatars.githubusercontent.com/u/16879430\u0026#34;) 5embed.add_field(name=\u0026#34;Field 1\u0026#34;, value=\u0026#34;Not an inline field!\u0026#34;, inline=False) 6embed.add_field(name=\u0026#34;Field 2\u0026#34;, value=\u0026#34;An inline field!\u0026#34;, inline=True) 7embed.add_field(name=\u0026#34;Field 3\u0026#34;, value=\u0026#34;Look I\u0026#39;m inline with field 2!\u0026#34;, inline=True) 8embed.set_footer(text=\u0026#34;Wow! A footer!\u0026#34;, icon_url=\u0026#34;https://cdn.discordapp.com/emojis/754736642761424986.png\u0026#34;) Remember that you need to send the embed to a channel too. This means you need to call send(embed=embed) on a messageable object, for example a TextChannel object (i.e. message.channel.send) or a Context object (ctx.send) or the embed will not be sent.\nThere are a few more things that haven't been covered here, but they're generally less commonly used, and if you want to learn more about them, I recommend you read the discord.py docs on embeds.\nNow that we're done with embeds, you can move on to the next part, Cooldowns!\nNext: Cooldowns ","link":"https://vcokltfre.dev/tutorial/10-embeds/","title":"10 - All About Embeds"},{"body":"You may often find a need when making bots to give commands their own cooldowns, to ensure that they're not called too often. There are a variety of reasons for this, such as mitigating spam, or fairly commonly, making sure people don't send too many requests if the command is an API intensive one.\nFortunately for us, discord.py provides built-in cooldown decorators that we can use on our existing commands that do just this. This will be a fairly small part, since there is not that much to cover on the topic, however I hope it will be of great use for ratelimiting your commands.\nTo start with, let's recap one of the commands we have from earlier, the setstatus command:\n1 @commands.command(name=\u0026#34;setstatus\u0026#34;) 2 async def setstatus(self, ctx: commands.Context, *, text: str): 3 \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; 4 await self.bot.change_presence(activity=discord.Game(name=text)) Now, we don't want someone seeing this in chat and deciding that they want to keep testing it over and over, that would be spammy and unwanted. So, we put a cooldown on the command. Cooldowns use decorators, just like how you defined that it was a command, as a few other things do also, which I'll show later in the tutorial. If we add a cooldown the command will end up looking like this:\n1 @commands.command(name=\u0026#34;setstatus\u0026#34;) 2 @commands.cooldown(rate=1, per=30) 3 async def setstatus(self, ctx: commands.Context, *, text: str): 4 \u0026#34;\u0026#34;\u0026#34;Set the bot\u0026#39;s status.\u0026#34;\u0026#34;\u0026#34; 5 await self.bot.change_presence(activity=discord.Game(name=text)) As you can see, we added the line @commands.cooldown(rate=1, per=30), which limits the command to be run once every 30 seconds globally (across all servers the bot is in).\nBy default the cooldown decorator uses commands.BucketType.default as it's bucket type - which is a global bucket. This means if I use !setstatus in my server, and Dave uses !setstatus in his server two seconds later, the command won't work for him, because the cooldown is global. Due to the global nature of the !setstatus command (the status can be seen globally, after all), I'll continue to use the global cooldown bucket, but you can use any of these bucket types.  Make note of the fact that BucketType.user and BucketType.member are different things. User will create a global cooldown for a single user across all servers the bot is in, whereas member is per guild.  Now we have an issue, if we run the command in rapid succession nothing happens - not even showing an error to the user. This can leave people fairly confused, \u0026quot;It worked for vco, why didn't it work for me?\u0026quot; which is why we now need to add error handling for it. Error handling will also be covered in far greater detail later in the tutorial, but for the purposes of this part, I'll add a simple one for the command. Adding an error handler for a command looks something like the following:\n1 @setstatus.error 2 async def setstatus_error(self, ctx: commands.Context, error): 3 if isinstance(error, commands.CommandOnCooldown): 4 await ctx.send(f\u0026#34;This command is on cooldown, try again after {round(error.retry_after)} seconds.\u0026#34;, delete_after=5) 5 print(error) I won't go over the error handling in detail here, but there is one new thing here I should mention. If you look in the ctx.send() function, you'll see a delete_after parameter, this tells discord.py to delete the message after the interval provided, so the error message gets deleted after a few seconds and doesn't clog up chat.\nThat's it for cooldowns, there isn't much more to know (though I suggest you check the docs page for them), you're now ready to move onto the next part!\n","link":"https://vcokltfre.dev/tutorial/11-cooldowns/","title":"11 - Cooldowns"},{"body":"discord.py Bot Tutorial A tutorial aiming to provide a detailed explanation of how to create a custom Discord bot using the discord.py library. This tutorial will walk you through all the aspects of creating your own bot, from creating the bot user itself on the Discord developer portal, to a brief overview of the Discord websocket gateway and HTTP API, to programming the bot itself.\n Some Notes Before Starting For this tutorial you will need:\n Python 3.6 or later installed discord.py 1.6.0 or later installed Intermediate Python experience or a strong will to learn  An incredibly useful resource to you throughout the tutorial will be the discord.py documentation\n The discord.py library is an advanced Python library. As such a certain amount of intermediate Python knowledge is assumed in this tutorial, and basic Python functionality will be not covered or explained. That being said, if you're willing to learn and search for things you don't understand as you follow along, there's no reason you shouldn't be able to participate.  The premise of this tutorial is that you write code yourself, and understand what you are writing. I aim to explain what I'm doing, and calrify the decisions I make, but this tutorial will not help you if you choose to copy and paste its content rather than try to understand and work it out for yourself. I highly recomment you play around with the code you write and make it different from what you see here. This is to help you learn how to use discord.py, not to give you the code for a bot.   Index  00 - Credits and Special Thanks 01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns  Extras  Tips - Tokens Tips - Allowed Mentions Tips - Client vs Bot Tips - Gateway Intents Tips - Storing Data   Start the Tutorial! ","link":"https://vcokltfre.dev/","title":"discord.py Bot Tutorial"},{"body":"Index  00 - Credits and Special Thanks 01 - Creating a Bot User 02 - An Overview of Discord 03 - Hello, world! 04 - A Ping Command 05 - Cogs 06 - Online! 07 - Welcome 08 - A Better Ping Command 09 - What Did That Message Say? 10 - All About Embeds 11 - Cooldowns   Start the Tutorial! See the Credits! ","link":"https://vcokltfre.dev/tutorial/","title":"discord.py Bot Tutorial"}]